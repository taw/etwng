#!/usr/bin/env ruby

require "fileutils"

$: << File.dirname(__FILE__)
require "esf_scripts"

class File
  def self.write(path, contents)
    File.open(path, 'wb'){|fh| fh.write contents}
  end
end

class SVG
  attr_accessor :width, :height, :transform
  def initialize
    @contents = []
    @width = "100%"
    @height = "100%"
    @transform = ""
  end
  def <<(cnt)
    @contents << cnt
  end
  def add_path(vertices, style)
    path = "M" + vertices.map{|x,y| "#{x} #{y}"}.join(" L") + " Z"
    @contents << %Q[<path d="#{path}" style="#{style}"/>]
  end
  def set_view(x0, y0, x1, y1)
    dx, dy = x1-x0, y1-y0
    x0 -= 0.05 * dx
    x1 += 0.05 * dx
    y0 -= 0.05 * dy
    y1 += 0.05 * dy
    dx, dy = x1-x0, y1-y0
    dz = [dx, dy].max
    xsz = 1000 * (dx / dz)
    ysz = 1000 * (dy / dz)
    @transform = "scale(#{1000.0/dz}) translate(#{-x0}, #{-y0})"
    @width = "#{xsz}"
    @height = "#{ysz}"
  end
  def to_s
    rv = %Q@<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="#{width}" height="#{height}" version="1.1" xmlns="http://www.w3.org/2000/svg">
<g transform="#{transform}">@
    rv << @contents.join
    rv << "</g>\n"
    rv << "</svg>\n"
    rv
  end
  def save(file_name)
    File.write(file_name, to_s)
  end
end

class DragRegionsSVG < EsfScript
  def run!
    FileUtils.mkdir_p target_dir
    i=0
    update_each_xml("region_data*", "rec[@type='region_data']") do |rd|
      i+=1
      vertices = parse_vertices(rd)
      @world = SVG.new
      @world.set_view(-1280.0, -640.0, 1280.0, 640.0)
      rd.xpath("//xml_include").each do |xi|
        update_xml(xmldir + "/" + xi['path'], '/rec') do |region|
          draw_region(region, vertices)
          false
        end
      end
      @world.save("#{target_dir}/world-#{i}.svg")
      false
    end
  end
  
  def parse_vertices(region_data_node)
    vertices = []
    data = region_data_node.xpath("//rec[@type='vertices']/v2_ary")[0].content.strip.split(/[\s,]+/)
    vertices << [data.shift.to_f, -data.shift.to_f] until data.empty?
    vertices
  end
  
  def rgb(r,g,b)
    "#%02X%02X%02X" % [r*255,g*255,b*255].map(&:round)
  end
  
  def hsv(h, s, v)
    h %= 6.0
    i = h.floor.to_i
    f = h-i
    f = 1-f if i&1 == 0
    m = v * (1-s)
    n = v * (1-s*f)
    case i
    when 0 then rgb(v,n,m)
    when 1 then rgb(n,v,m)
    when 2 then rgb(m,v,n)
    when 3 then rgb(m,n,v)
    when 4 then rgb(n,m,v)
    when 5 then rgb(v,m,n)
    else
      raise "FAIL #{i} / hsv(#{h},#{s},#{v})"
    end
  end
  
  def random_land_color
    hsv(0.0+rand*2.0, 0.50+rand*0.50, 0.50+rand*0.25)
  end  
  def random_sea_color
    hsv(2.5+rand*1.0, 0.50+rand*0.50, 0.75+rand*0.25)
  end
  
  def draw_region(region, vertices)
    name = region.xpath("s")[0].content
    type = region.xpath("asc")[0].content
    areas = region.xpath("//rec[@type='areas']")
    areas = areas.map{|area_node| parse_area(area_node, vertices)}
    svg = SVG.new
    xs=[]
    ys=[]
    
    if type == 'land'
      region_color = random_land_color
    else
      region_color = random_sea_color
    end
    
    areas.each{|area|
      # area[:faces].each{|face|
      #   svg << %Q[<path d="#{face}" />\n]
      # }
      area[:outlines].each_with_index{|outline, i|
        xs = xs + outline.map{|x,y| x}
        xs = [xs.min, xs.max]
        ys = ys + outline.map{|x,y| y}
        ys = [ys.min, ys.max]
        color = random_land_color
        style="fill:#{color};fill-opacity:0.2;stroke:#{color};stroke-width:0.2px;"
        svg.add_path(outline, style)
        style2="stroke-width:0.5px;stroke:black;fill-opacity:0.2;fill:#{region_color}"
        @world.add_path(outline, style2)
      }
    }
    svg.set_view(xs.min, ys.min, xs.max, ys.max)
    svg.save("#{target_dir}/#{name}.svg")
  end
  def parse_area(area_node, vertices)
    {
      :faces => area_node.xpath("rec[@type='faces']/u4_ary").map{|face| u4_ary_to_path(face.content, vertices)},
      :outlines => area_node.xpath("//rec[@type='outlines']/u4_ary").map{|face| u4_ary_to_path(face.content, vertices)},
    }
  end
  
  def u4_ary_to_path(u4_ary, vertices)
    u4_ary.strip.split(/\s+/).map{|x| vertices[x.to_i]}
  end
  
  def target_dir
    "regions_svg"
  end
end

DragRegionsSVG.new
